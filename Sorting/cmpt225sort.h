#pragma once
#include<stdexcept>
#include <iostream>
#include <fstream>
#include <vector>
using namespace std;
// DO NOT EDIT THIS FILE IN ANY WAY

/* a function I used to help to see if the function sort things correctly
template<class T> void show(T arr[],int n){
    for (int i=0;i<n;i++){
        cout<<arr[i]<<" ";
    }
    cout<<endl;
}
*/

//Swap function to help with the Quicksort
void swap(int* a, int* b)
{
    int t = *a;
    *a = *b;
    *b = t;
}

/*Insertionsort that sorts its array parameter using the insertion sort algorithm. The function should have two parameters, an array of any type (a template variable), and an integer that records the size of the array. */
template <class T>
int insertionsort(T arr[], int n){
  int cnt = 0;
  for(int i = 1; i < n; ++i){
    T temp = arr[i];
    int pos = i;
    cnt++; //count for the barometer operation for the termial comparsion
    while(pos > 0 && arr[pos - 1] > temp){
      arr[pos] = arr[pos - 1];
      cnt++; //count inside the loop for the barometer operation
      pos--;
    } //while
      
// Insert the current item
    arr[pos] = temp;
  }
  return cnt;
}


/*Partition function. This function should return the index of the pivot element with an integer reference parameter to the function that record the comparison count*/
template <class T>
int QSPartition(T arr[], int low, int high, int& counter)
{
         T pivot = arr[low];// record the pivot
         while (low < high)
         {
         while (low < high && arr[high] >= pivot) { //barometer operation
         --high;
         counter++;
         }
         arr[low] = arr[high]; //move the value smaller than pivot to the left side of pivot
         while (low < high && arr[low] <= pivot) { //barometer operation
         ++low;
         counter++;
         }
         arr[high] = arr[low]; //move the value larger than pivot to the right side of pivot
       }
       counter+=2;//barometer operation for both termial comparsion
       arr[low] = pivot;
       return low; // give the position of pivot
}

/*Quicksort function helper*/
template <class T>
int Quicksort(T arr[], int low, int high, int &counter)
{
    int pIndex;//pivot
    if(low >= high)//base case
        return 1;
    //Barometer operation cacluated in all three functions (comparisons to the pivot)
    pIndex = QSPartition(arr, low, high, counter);//pIndex sorted
    Quicksort(arr, low, pIndex-1, counter);
    Quicksort(arr, pIndex+1, high, counter);
    return counter;
}

/*Template function called quicksort that sorts its array parameter using the quicksort algorithm. The function should have two parameters, an array of any type (a template variable), and an integer that records the size of the array. The function return an integer that equals the number of times its barometer operation is executed.*/
template <class T>
int quicksort(T arr[], int n)
{
    int count = 0;
    Quicksort(arr, 0, n-1, count);
    return count;
}

template <class T>
int mergesort(T arr[],int n){
        int count = 0;
        T *a = arr;
        T *b = new T[n];
        //SEG: the step size is doubled in each cycle until it exceeds the length of the array
        for (int seg = 1; seg < n; seg += seg) {
            //Compare the interval of 2 * SEG numbers, and then move back 2 * SEG numbers for comparison, and so on until it exceeds the length of the array
            for (int start = 0; start < n; start += 2*seg) {
                int low = start, mid = min(start + seg, n), high = min(start + seg + seg, n);
                int k = low;
                int start1 = low, end1 = mid;
                int start2 = mid, end2 = high;
                while (start1 < end1 && start2 < end2) // comparsion which did the most.
                {
                    count++; //barometer operation ++
                    if(a[start1] < a[start2])
                    {
                        b[k++]=a[start1++];
                    }
                    else
                    {
                        b[k++]=a[start2++];
                    }
                }
                //If the comparisons in the first range did not complete
                while (start1 < end1)
                {
                    b[k++] = a[start1++];
                }
                //If the comparisons in the second range did not complete
                while (start2 < end2)
                {
                    b[k++] = a[start2++];
                }
            }
            T *temp = a;
            a = b;
            b = temp;
        }
        count++;// termial condition barometer operation ++
        //Transfer a (merged data) to b (arr []), and then release the original b
        if (a != arr) {
            for (int i = 0; i < n; i++)
                b[i] = a[i];
            b = a;
        }
        
        delete[] b;// Memory management!
        return count;
    }




/*Cite: ShellSort GeeksforGeeks */
template <class T>
int shellsort(T arr[], int n)
{
    int cnt = 0;
    int j;
    //Narrow the array by 2 everytime
    for (int gap = n / 2; gap > 0; gap /= 2)
    {
        for (int i = gap; i < n; ++i)
        {
            T temp = arr[i];//element to be compared
            //compare element j until all interal elements compared, stop if exceeds interval set or temp value becomes greater than compared element
            for (j = i; j >= gap && temp < arr[j - gap]; j -= gap,cnt++) //Barometer operation for all the comparsions (Termial comparsion included)
            {
                arr[j] = arr[j - gap];//swap (move up) as long as temp is < compared
            }
            cnt++;
            arr[j] = temp;//swap final element
        }//continue
    }

    return cnt;
}


 


